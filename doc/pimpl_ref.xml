<?xml version="1.0" standalone="yes"?>
<library-reference id="pimpl_reference"><title>Pimpl Reference</title><header name="/home/vb/dev/pimpl/include/pimpl.hpp">
<struct name="pimpl"><template>
      <template-type-parameter name="user_type"/>
      <template-type-parameter name="user_allocator"><default>void</default></template-type-parameter>
    </template><struct name="base"><template>
      <template-type-parameter name=""/>
    </template><struct name="null_type"/><typedef name="implementation"><type>typename <classname>pimpl</classname>&lt; user_type &gt;::implementation</type></typedef>
<typedef name="pimpl_type"><type><classname>base</classname></type></typedef>
<typedef name="managed_type"><type>typename manager::type</type></typedef>
<typedef name="rm_ref"><type>typename std::remove_reference&lt; T &gt;::type</type></typedef>
<typedef name="is_base_of"><type>typename std::is_base_of&lt; <classname>base</classname>, rm_ref&lt; T &gt;&gt;</type></typedef>
<typedef name="is_derived"><type>typename std::enable_if&lt; is_base_of&lt; T &gt;::value, <classname>null_type</classname> * &gt;::type</type></typedef>
<method-group name="public member functions">
<method name="operator!" cv="const"><type>bool</type></method>
<method name="conversion-operator" cv="const" specifiers="explicit"><type>bool</type></method>
<method name="operator==" cv="const"><type>bool</type><parameter name="that"><paramtype><classname>pimpl_type</classname> const &amp;</paramtype></parameter></method>
<method name="operator!=" cv="const"><type>bool</type><parameter name="that"><paramtype><classname>pimpl_type</classname> const &amp;</paramtype></parameter></method>
<method name="operator&lt;" cv="const"><type>bool</type><parameter name="that"><paramtype><classname>pimpl_type</classname> const &amp;</paramtype></parameter></method>
<method name="swap"><type>void</type><parameter name="that"><paramtype><classname>pimpl_type</classname> &amp;</paramtype></parameter></method>
<method name="swap"><type>void</type><parameter name="that"><paramtype>managed_type &amp;</paramtype></parameter></method>
<method name="reset"><type>void</type><parameter name="p"><paramtype>implementation *</paramtype></parameter></method>
<method name="reset"><type>void</type><template>
          <template-type-parameter name="Y"/>
          <template-type-parameter name="D"/>
        </template><parameter name="p"><paramtype>Y *</paramtype></parameter><parameter name="d"><paramtype>D</paramtype></parameter></method>
<method name="operator-&gt;" cv="const"><type>implementation const *</type></method>
<method name="operator*" cv="const"><type>implementation const &amp;</type></method>
<method name="operator-&gt;"><type>implementation *</type></method>
<method name="operator*"><type>implementation &amp;</type></method>
<method name="use_count" cv="const"><type>long</type></method>
</method-group>
<method-group name="protected member functions">
</method-group>
<constructor><parameter name=""><paramtype><classname>null_type</classname></paramtype></parameter></constructor>
<constructor/>
<constructor><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;&amp;</paramtype></parameter><parameter name=""><paramtype>is_derived&lt; Arg &gt;</paramtype><default>0</default></parameter></constructor>
<constructor><template>
          <template-nontype-parameter name="Args"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter></constructor>
</struct><struct name="shared_mgr"><typedef name="alloc"><type><classname>pimpl</classname>&lt; user_type, user_allocator &gt;::allocator</type></typedef>
<typedef name="impl"><type><classname>pimpl</classname>&lt; user_type, user_allocator &gt;::implementation</type></typedef>
<typedef name="type"><type>std::shared_ptr&lt; impl &gt;</type></typedef>
<method-group name="public static functions">
<method name="make" specifiers="static"><type>type</type><template>
          <template-nontype-parameter name="Args"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter></method>
</method-group>
</struct><struct name="value_mgr"><struct name="value_ptr"><template>
      <template-type-parameter name="impl_type"/>
    </template><struct name="deep_copy"><inherit access="public">pimpl&lt; user_type, user_allocator &gt;::value_mgr::value_ptr::traits</inherit><method-group name="public member functions">
<method name="destroy" cv="const" specifiers="virtual"><type>void</type><parameter name="p"><paramtype>impl_type *&amp;</paramtype></parameter></method>
<method name="copy" cv="const" specifiers="virtual"><type>impl_type *</type><parameter name="p"><paramtype>impl_type const *</paramtype></parameter></method>
<method name="assign" cv="const" specifiers="virtual"><type>void</type><parameter name="a"><paramtype>impl_type *&amp;</paramtype></parameter><parameter name="b"><paramtype>impl_type const *</paramtype></parameter></method>
<method name="conversion-operator"><type>traits const *</type></method>
</method-group>
</struct><struct name="traits"><method-group name="public member functions">
<method name="destroy" cv="const" specifiers="virtual"><type>void</type><parameter name=""><paramtype>impl_type *&amp;</paramtype></parameter></method>
<method name="copy" cv="const" specifiers="virtual"><type>impl_type *</type><parameter name=""><paramtype>impl_type const *</paramtype></parameter></method>
<method name="assign" cv="const" specifiers="virtual"><type>void</type><parameter name=""><paramtype>impl_type *&amp;</paramtype></parameter><parameter name=""><paramtype>impl_type const *</paramtype></parameter></method>
<method name="conversion-operator"><type>traits const *</type></method>
</method-group>
<destructor/>
</struct><method-group name="public member functions">
<method name="operator&lt;" cv="const"><type>bool</type><parameter name="that"><paramtype><classname>value_ptr</classname> const &amp;</paramtype></parameter></method>
<method name="reset"><type>void</type><parameter name="p"><paramtype>impl_type *</paramtype></parameter></method>
<method name="swap"><type>void</type><parameter name="that"><paramtype><classname>value_ptr</classname> &amp;</paramtype></parameter></method>
<method name="get"><type>impl_type *</type></method>
<method name="get" cv="const"><type>impl_type const *</type></method>
<method name="use_count" cv="const"><type>long</type></method>
</method-group>
<destructor/>
<constructor/>
<constructor><parameter name="p"><paramtype>impl_type *</paramtype></parameter></constructor>
<constructor><parameter name="that"><paramtype><classname>value_ptr</classname> const &amp;</paramtype></parameter></constructor>
<copy-assignment><type><classname>value_ptr</classname> &amp;</type><parameter name="that"><paramtype><classname>value_ptr</classname> const &amp;</paramtype></parameter></copy-assignment>
</struct><typedef name="alloc"><type><classname>pimpl</classname>&lt; user_type, user_allocator &gt;::allocator</type></typedef>
<typedef name="impl"><type><classname>pimpl</classname>&lt; user_type, user_allocator &gt;::implementation</type></typedef>
<typedef name="type"><type><classname>value_ptr</classname>&lt; impl &gt;</type></typedef>
<method-group name="public static functions">
<method name="make" specifiers="static"><type>impl *</type><template>
          <template-nontype-parameter name="Args"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter></method>
</method-group>
</struct><typedef name="unique"><type><classname>base</classname>&lt; <classname>value_mgr</classname> &gt;</type></typedef>
<typedef name="shared"><type><classname>base</classname>&lt; <classname>shared_mgr</classname> &gt;</type></typedef>
<typedef name="yes_type"><type>boost::type_traits::yes_type</type></typedef>
<typedef name="no_type"><type>boost::type_traits::no_type</type></typedef>
<typedef name="ptr_type"><type>typename std::remove_reference&lt; user_type &gt;::type *</type></typedef>
<typedef name="allocator"><type>typename std::conditional&lt; std::is_void&lt; user_allocator &gt;::value, std::allocator&lt; implementation &gt;, user_allocator &gt;::type</type></typedef>
<method-group name="public static functions">
<method name="test" specifiers="static"><type>yes_type</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name=""><paramtype>Y const *</paramtype></parameter><parameter name=""><paramtype>typename Y::pimpl_type const *</paramtype><default>0</default></parameter></method>
<method name="test" specifiers="static"><type>no_type</type><parameter name=""><paramtype>...</paramtype></parameter></method>
<method name="null" specifiers="static"><type>user_type</type></method>
</method-group>
<method-group name="public member functions">
<method name="BOOST_STATIC_CONSTANT"><type/><parameter name=""><paramtype>bool</paramtype></parameter><parameter name=""><paramtype>value</paramtype><default>(1==sizeof(test(ptr_type(nullptr))))</default></parameter></method>
</method-group>
</struct><namespace name="boost">
<typedef name="pimpl"><type>::<classname>pimpl</classname>&lt; user_type, alloc &gt;</type></typedef>
</namespace>
</header>
</library-reference>