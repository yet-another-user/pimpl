[section Getting Started]

Let's start with a fairly basic and conventional

 struct Book
 {
    Book (string const& title, string const& author);
    ...
    string const&  title() const;
    string const& author() const;

    private:
  
    string  title_;
    string author_;
    int     price_;
 };


Say, due to reasons mentioned in the ['Introduction] we would like to transform it to a ['Pimpl]-style class with the ['pointer semantics]. That is:

* we intend to separate the interface from the implementation and to hide implementation through the deployment of the ['Pimpl] idiom;
* we intend the class to have ['pointer semantics], i.e. with regard to the underlying data it will behave in the smart-pointer/shared-proxy fashion by allowing shared access to the actual implementation data.

In that setting the ['Book] definition might probably change to as follows: 

 struct Book
 {
    Book(string const& title, string const& author);
    ...
    string const&  title() const;
    string const& author() const;
  
    bool operator== (Book const& other) const { return impl_ == other.impl_; }
    bool operator!= (Book const& other) const { return !operator==(other); }

    explicit operator bool () const { return  bool(impl_); }
    bool         operator! () const { return !bool(impl_); }
  
    private:
  
    struct implementation;
    std::shared_ptr<implementation> impl_;
 };

[important That fairly standard ['Pimpl] idiom deployment splits the original class (accommodating behavior ['and] data, public ['and] private) into two classes -- the public interface (the ['Book] class) and the private implementation (the ['Book::implementation] class). 

At first glance, that might appear as breaking the established Object-Oriented programming paradigm -- the association between data and behavior -- enshrined in the fundamental concept of an ['object] or a ['class] and routinely seen/implemented as such -- one class. 

That one-class approach is not exactly ideal for reasons mentioned in the ['Introduction]. However, the fault-line where the ['Pimpl] splits the conventional class in two is not ['exactly] between ['data and behavior]. It is, rather, between ['public interface] (public behavior) and ['private implementation] (private data and behavior) -- two different views of a system. They serve different purposes and are better managed when kept separate. 

The ['Pimpl] technique seems to fit that objective better with ['actual] rather than ['notional] separation.]  
 
So far applying the ['Pimpl] idiom is fairly straightforward as ['std::shared_ptr] takes care of much of the scaffolding hassle. The auto-generated destructor, copy constructor and assignment operator suffice and writing the comparison operators is child's play.

Still, from design perspectives lumping the application logic with the infrastructure scaffolding is messy. Moreover, in our (admittedly simple) ['Book] class more than half of the code is the ['Pimpl]-related scaffolding. For one class in isolation that might not look like that big a deal. On a larger scale, reading, understanding and maintaining extra code, mentally separating the application logic from the infrastructure scaffolding, repeatedly making sure nothing is forgotten, misused, or misplaced is a tiring and wasteful exercise. The following, therefore, seems like an improvement: 

 struct Book : public pimpl<Book>::shared
 {
    Book(string const& title, string const& author);
    
    string const&  title() const;
    string const& author() const;
 };

With no loss in functionality it is shorter, application-focused and reasonably self-documented. The most important quality though is that it consists of nothing but ['pure application-specific interface]. It does not even need to be a class as often there is nothing to restrict access to. 

With such a clean ['separation of concerns] (public interface and private implementation) the technique is ideal for building large-scale systems and then, most importantly, managing evolution of those systems. 

[note Designing large-scale systems in general might probably be described as ['API-centered design]. For such systems considerable initial effort goes into designing interface specifications for modules/components (high-level/architectural design) and classes (low-level/detailed design). That allows further development to proceed to a large degree in parallel -- with the service consumer relying on those contractual obligations (imposed by the API) and with the service provider working towards meeting those contractual obligations. The better/cleaner the interface/implementation separation of concerns is, the fewer there are dependencies and interruptions of that parallel development process.]

[endsect]
